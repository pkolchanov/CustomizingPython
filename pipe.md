> [!WARNING]
> Disclaimer: I'm a Python internals newbie, and I'm writing this to teach myself.


## Introdution

The goal is to add an operator to perfom bash-like chain calls:
```python
>>> [1,2] |> map(lambda x:x*2) |> list()

[2, 4]
```

## Plan

According to [CPython devguide](https://devguide.python.org/internals/compiler/), the compilation of source code involves several steps: 
 
> 1. Tokenize the source code (Parser/lexer/ and Parser/tokenizer/).
>
> 2. Parse the stream of tokens into an Abstract Syntax Tree (Parser/parser.c).
>
> 2. Transform AST into an instruction sequence (Python/compile.c).
> 
> 2. Construct a Control Flow Graph and apply optimizations to it (Python/flowgraph.c).
>
> 3. Emit bytecode based on the Control Flow Graph (Python/assemble.c).

To implement `|>` we are going to modfy 3 steps: modify parsing and compilation process to default bytecode instructions.  


## Parsing 

#### Tokenezation 
Let's start with tokenization. Tokenization is a process of splitting an input string into a sequence of tokens. 

Add a new `PIPE` token to the  `Grammar/Tokens`
```diff 
 ELLIPSIS                '...'
 COLONEQUAL              ':='
 EXCLAMATION             '!'
+PIPE                    '|>'
```

And run `make regen-token` to regenerate `pycore_token.h`, `Parser/token.c`, `Lib/token.py`. 

For example, look to the changes of the `Parser/token.c`. `regen-token` added a case to a parser code:

```diff
     case '|':
         switch (c2) {
         case '=': return VBAREQUAL;
+        case '>': return PIPE;
         }
         break;
     }
```
#### ASDL

Next, move to `Parser/Python.asdl`. ASDL is a blueprint for python AST nodes.

Let's add a new node type â€“ PipeOP expression.

```diff
     expr = BoolOp(boolop op, expr* values)
          | NamedExpr(expr target, expr value)
          | BinOp(expr left, operator op, expr right)
+         | PipeOp(expr left, expr right)
          | UnaryOp(unaryop op, expr operand)
          | Lambda(arguments args, expr body)
          | IfExp(expr test, expr body, expr orelse)
```

Then run `make regen-ast` to regenerate `pycore_ast.h` and `Python/Python-ast.c`. 

Look to the changes of the `Python/Python-ast.c`. `regen-ast` generated constructor fuction for pipe operatior expression. 
```c
expr_ty
_PyAST_PipeOp(expr_ty left, expr_ty right, int lineno, int col_offset, int
              end_lineno, int end_col_offset, PyArena *arena)
{
    expr_ty p;
    if (!left) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'left' is required for PipeOp");
        return NULL;
    }
    if (!right) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'right' is required for PipeOp");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = PipeOp_kind;
    p->v.PipeOp.left = left;
    p->v.PipeOp.right = right;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}
```

#### Grammar

Now let's move to `Parser/python.gram`. 

This file contains the whole python grammar.  In short: it describes how to construct an abstract syntax tree using the grammar rules.


Add a `pipe_op` expression defention. 

```diff

 power[expr_ty]:
     | a=await_primary '**' b=factor { _PyAST_BinOp(a, Pow, b, EXTRA) }
+    | pipe_op
+
+pipe_op[expr_ty]:
+    | a=pipe_op '|>' b=await_primary { _PyAST_PipeOp(a, b, EXTRA) } 
     | await_primary
```

"When matching a `await_primary` after `|>`' token, construct a AST node using `_PyAST_PipeOp` function"

Then run `make regen-pegen` to regenerate  `Parser/parser.c`. 

#### Parsing to AST

The whole AST parser is already generated by `regen-pegen`.

We only need to update ast validation. Add an case for `PipeOp_king` to `Python/ast.c/validate_expr`. 

```diff
+    case PipeOp_kind:
+        if (exp->v.PipeOp.right->kind != Call_kind) {
+            PyErr_SetString(PyExc_TypeError,
+                            "Pipe op arg must be a function call");
+            return 0;
+        }
+        ret = validate_expr(state, exp->v.PipeOp.left, Load) &&
+        validate_expr(state, exp->v.PipeOp.right, Load);
+        break;
```


#### Test AST parstion

Recompile cypthon with `make -j4` and test the parser with `ast.parse` module:

!TODO
```python
>>> import ast
>>> tree = ast.parse('1 |> f()')
>>> ast.dump(tree)
```

## Compilation from AST to bytecode operations



The next stage is compilation. Now we need to translate an AST to a sequence of commands for the Python VM. 

#### Target bytecodes

`a |> f(b)` is the another way of saying `f(a, b)`

Let's look how `f(a, b)` is compiled bytecodes using `dis` module:

```python
>>> import dis
>>> dis.dis("f(a, b)")
  0           0 RESUME                   0

  1           2 PUSH_NULL
              4 LOAD_NAME                0 (f)
              6 LOAD_NAME                1 (a)
              8 LOAD_NAME                2 (b)
             10 PRECALL                  2
             14 CALL                     2
             24 RETURN_VALUE
```

Three things are happening here
1. Load a funtion to data stack using `LOAD_NAME`
2. Load value of `a` to stack using `LOAD_NAME`
3. Load value of  `b` to stack using `LOAD_NAME`
4. Call funtion using `CALL` with `2` arguments.

So, we need to add an additional argument between `LOAD_NAME 0 (f)` and `CALL`


#### Compile.c
Starting point is the `Python/compile.c` file.

Let's look to the `Python/compile.c/compiler_visit_expr1` . 

The function descibes compilation of an `expr_ty` AST node to with a simple switch:

```c
static int
compiler_visit_expr1(struct compiler *c, expr_ty e)
{
    location loc = LOC(e);
    switch (e->kind) {
    case NamedExpr_kind:
        VISIT(c, expr, e->v.NamedExpr.value);
        ADDOP_I(c, loc, COPY, 1);
        VISIT(c, expr, e->v.NamedExpr.target);
        break;
    case BoolOp_kind:
        return compiler_boolop(c, e);
...
```

Add a new case with for `PipeOp_kind`. Let's start with a copy of function call:

```diff
+    case PipeOp_kind:
+        return compiler_call(c, e->>v.PipeOp.right);
     case Lambda_kind:
         return compiler_lambda(c, e);
```

Recompile Cpython with `make -j4` and try new operator:


!TODO
```python
>>> 1 |> f()

BLAH BLAH
```

#### Symbables 

The purpose of the symbol table resolving is to resolving scopes. 

Look to to the `Python/symtable.c/symtable_visit_expr`. The fuction recurcively visits AST and builds symbol tables. 
```c
static int
symtable_visit_expr(struct symtable *st, expr_ty e)
{
    ...
    switch (e->kind) {
    case NamedExpr_kind:
        if (!symtable_raise_if_annotation_block(st, "named expression", e)) {
            VISIT_QUIT(st, 0);
        }
        if(!symtable_handle_namedexpr(st, e))
            VISIT_QUIT(st, 0);
        break;
    case BoolOp_kind:
        VISIT_SEQ(st, expr, e->v.BoolOp.values);
        break;
    ....
```

Add a case for a `PipeOP_kind`

```diff
     case BinOp_kind:
         VISIT(st, expr, e->v.BinOp.left);
         VISIT(st, expr, e->v.BinOp.right);
+        break;
+    case PipeOp_kind:
+        VISIT(st, expr, e->v.PipeOp.left);
+        VISIT(st, expr, e->v.PipeOp.right);
         break;
     case UnaryOp_kind:
         VISIT(st, expr, e->v.UnaryOp.operand);
```

Recompile cypthon with `make -j4` and test the parser with `symtables` module

#### Compilaton 

Move back to the `Python/compile.c/compiler_visit_expr1` and redefine case for `PipeOp_kind` with `compiler_pipe_call``:

```diff
+    case PipeOp_kind:
+        return compiler_pipe_call(c, e);
     case Lambda_kind:
         return compiler_lambda(c, e);
```

Let's start with an excact copy of compiler_call:

```c
static int compiler_pipe_call(struct compiler *c, expr_ty e) {
    expr_ty func_e = e->v.PipeOp.right;
    expr_ty arg_e = e->v.PipeOp.left;

    RETURN_IF_ERROR(validate_keywords(c, func_e->v.Call.keywords));
    int ret = maybe_optimize_method_call(c, func_e);
    if (ret < 0) {
        return ERROR;
    }
    if (ret == 1) {
        return SUCCESS;
    }
    
    RETURN_IF_ERROR(check_caller(c, func_e->v.Call.func));
    VISIT(c, expr, func_e->v.Call.func);
    location loc = LOC(func_e->v.Call.func);
    ADDOP(c, loc, PUSH_NULL);
    loc = LOC(func_e);

    return compiler_call_helper(c, loc, 0,
                                func_e->v.Call.args,
                                func_e->v.Call.keywords);
}

```

Next, we need to add an argument from left pipe op node to to `v.Call.args`.

Copy original call argumenets using ` asdl_seq_SET`, and add left pipe expression as a last argument:

```diff

+    Py_ssize_t original_len = asdl_seq_LEN(func_e->v.Call.args);
+    asdl_expr_seq *bases = _Py_asdl_expr_seq_new(
+            original_len+1, c->c_arena);
+    
+    for (Py_ssize_t i = 0; i < original_len; i++) {
+            asdl_seq_SET(bases, i, asdl_seq_GET(func_e->v.Call.args, i));
+    }
+    asdl_seq_SET(bases, original_len, arg_e);

-    return compiler_call_helper(c, loc, 0,
-                                func_e->v.Call.args,
-                                func_e->v.Call.keywords);

+    return compiler_call_helper(c, loc, 0,
+                                bases,
+                                func_e->v.Call.keywords);
+}
```

Thats it!

Recompile Cpython with `make -j4` and try new operator:


```python
>>> [1,2] |> map(lambda x:x*2) |> list()

[2, 4]
```

